import { DevToolsWriter, type DevToolsEntry, type EndpointType, type DevToolsConfig } from "@ai-stats/devtools-core";
import { randomUUID } from "crypto";

/**
 * Telemetry capture for TypeScript SDK
 * Captures API requests asynchronously with minimal performance impact
 */
export class TelemetryCapture {
  private readonly enabled: boolean;
  private readonly writer: DevToolsWriter;
  private readonly queue: DevToolsEntry[] = [];
  private readonly flushIntervalMs: number;
  private readonly maxQueueSize: number;
  private flushTimer: NodeJS.Timeout | null = null;
  private readonly sdkVersion: string;

  constructor(config?: Partial<DevToolsConfig>, sdkVersion: string = "0.2.1") {
    // Check if devtools is enabled via env var or config
    this.enabled = config?.enabled ?? process.env.AI_STATS_DEVTOOLS === "true";
    this.sdkVersion = sdkVersion;

    if (!this.enabled) {
      this.writer = null as any; // Won't be used if disabled
      this.flushIntervalMs = 0;
      this.maxQueueSize = 0;
      return;
    }

    const directory = config?.directory ?? process.env.AI_STATS_DEVTOOLS_DIR ?? ".ai-stats-devtools";
    this.writer = new DevToolsWriter(directory);
    this.flushIntervalMs = config?.flushIntervalMs ?? 1000;
    this.maxQueueSize = config?.maxQueueSize ?? 1000;

    // Initialize directory structure
    this.writer.ensureDirectory();

    // Write session metadata
    this.writer.writeSessionMetadata({
      session_id: randomUUID(),
      started_at: Date.now(),
      sdk: "typescript",
      sdk_version: this.sdkVersion,
      platform: process.platform,
      node_version: process.version
    });

    // Start flush interval
    this.startFlushInterval();
  }

  /**
   * Capture a request/response pair
   * This is non-blocking and queues the entry for async persistence
   */
  capture(entry: Omit<DevToolsEntry, "metadata"> & { metadata: Partial<DevToolsEntry["metadata"]> }): void {
    if (!this.enabled) return;

    // Complete metadata
    const completeEntry: DevToolsEntry = {
      ...entry,
      metadata: {
        sdk: "typescript",
        sdk_version: this.sdkVersion,
        stream: false,
        ...entry.metadata
      }
    };

    // Add to queue
    this.queue.push(completeEntry);

    // Flush immediately if queue is full
    if (this.queue.length >= this.maxQueueSize) {
      this.flushSync();
    }
  }

  /**
   * Helper to create a telemetry wrapper for a method
   */
  wrap<T>(
    type: EndpointType,
    fn: () => Promise<T>,
    getRequest: () => Record<string, any>,
    extractMetadata?: (response: T) => Partial<DevToolsEntry["metadata"]>
  ): Promise<T> {
    if (!this.enabled) {
      return fn();
    }

    const id = randomUUID();
    const startTime = Date.now();

    return fn()
      .then((response) => {
        const duration = Date.now() - startTime;

        this.capture({
          id,
          type,
          timestamp: startTime,
          duration_ms: duration,
          request: getRequest(),
          response: response as any,
          error: null,
          metadata: {
            ...extractMetadata?.(response)
          }
        });

        return response;
      })
      .catch((error) => {
        const duration = Date.now() - startTime;

        this.capture({
          id,
          type,
          timestamp: startTime,
          duration_ms: duration,
